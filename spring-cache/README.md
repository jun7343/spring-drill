# Spring Cache

## 개요

캐싱의 내부 동작 방식을 이해하고, 다양한 캐싱 전략을 설계하고 구현하는 방법을 학습합니다. 이를 통해 애플리케이션의 성능을 최적화하고, 데이터 접근 속도를 향상시키는 방법을 익힙니다.

## 목표

- Spring Framework에서 제공하는 캐싱 추상화 기능을 이해합니다.
- 다양한 캐싱 전략(예: 메모리 캐시, 분산 캐시 등)을 구현하고 활용하는 방법을 학습합니다.
- 캐시 무효화 및 갱신 전략을 이해합니다.
- 실제 애플리케이션에서 캐싱을 적용하여 성능을 향상시키는 방법을 학습합니다.
- Spring Cache와 함께 사용할 수 있는 다양한 캐시 제공자(예: Ehcache, Redis 등)를 이해합니다.
- 캐싱과 관련된 모니터링 및 로깅 기법을 학습합니다.
- 캐싱이 애플리케이션 성능에 미치는 영향을 평가하는 방법을 학습합니다.
- 캐싱 전략을 설계하고 구현하는 실습을 통해 실무 능력을 향상시킵니다.
- 캐싱과 관련된 최신 트렌드와 기술을 학습합니다.
- 캐싱과 관련된 문제 해결 및 최적화 기법을 학습합니다.

## 캐시 설계

- 캐싱 요구사항 분석
  - 애플리케이션의 성능 병목 지점을 식별합니다.
  - 캐싱이 필요한 데이터 유형과 사용 패턴을 분석합니다.
  - 캐싱의 목표(예: 응답 시간 단축, 데이터베이스 부하 감소 등)를 명확히 정의합니다.
  - 캐시 지역성(지역성 원칙: 시간 지역성, 공간 지역성)을 고려합니다.
    - 시간 지역성: 최근에 접근한 데이터는 다시 접근할 가능성이 높음.
    - 공간 지역성: 특정 데이터와 인접한 데이터는 함께 접근될 가능성이 높음.
- 캐싱 계층 설계
  - 애플리케이션 아키텍처에서 캐싱 계층을 어떻게 설계할지 결정합니다.
  - 예: 클라이언트 측 캐시, 서버 측 캐시, 분산 캐시 등.
  - 각 계층의 역할과 책임을 명확히 정의합니다.
- 캐싱 정책 수립
  - 캐시할 데이터의 유형과 특성을 분석합니다.
  - 캐시 만료 시간, 갱신 주기, 캐시 크기 제한 등의 정책을 수립합니다.
- 데이터 일관성 관리
    - 캐시와 원본 데이터 간의 일관성을 유지하는 방법을 결정합니다.
    - 예: 쓰기 동기화, 읽기 동기화, 이벤트 기반 갱신 등.
- 캐시 무효화 전략
  - 데이터 변경 시 캐시를 어떻게 무효화할지 결정합니다.
  - 예: 시간 기반 만료, 이벤트 기반 무효화, 수동 무효화 등.
- 모니터링 및 로깅
  - 캐시 성능과 효율성을 모니터링하는 방법을 설계합니다.
  - 캐시 히트율, 미스율, 응답 시간 등의 지표를 추적합니다.
- 확장성 고려
  - 캐시 시스템이 증가하는 데이터와 트래픽을 처리할 수 있도록 확장성을 고려합니다.
  - 분산 캐시 솔루션을 도입할지 여부를 결정합니다.
- 보안 고려
  - 캐시된 데이터의 보안 요구사항을 분석합니다.
  - 민감한 데이터의 암호화, 접근 제어 등의 보안 조치를 설계합니다.

## 캐시 전략

- Cache Aside Pattern
  - 설명: 애플리케이션이 캐시에 먼저 데이터를 조회하고, 캐시에 데이터가 없으면 데이터 소스에서 데이터를 가져와 캐시에 저장하는 패턴.
  - 장점: 애플리케이션이 캐시와 데이터 소스 간의 동기화를 직접 관리할 수 있어 유연성이 높음.
  - 단점: 애플리케이션 코드가 복잡해질 수 있으며, 캐시 미스 시 데이터 소스에 대한 추가 호출이 발생할 수 있음.
- Read Through Pattern
  - 설명: 캐시가 데이터 소스와 통합되어 있어, 애플리케이션이 캐시에서 데이터를 조회할 때 캐시에 데이터가 없으면 자동으로 데이터 소스에서 데이터를 가져와 캐시에 저장하는 패턴.
  - 장점: 애플리케이션 코드가 단순해지며, 캐시 미스 시에도 자동으로 데이터 소스에서 데이터를 가져옴.
  - 단점: 캐시와 데이터 소스 간의 동기화가 어려울 수 있으며, 캐시 제공자가 데이터 소스와의 통합을 지원해야 함.
- Write Through Pattern
  - 설명: 애플리케이션이 데이터를 캐시에 저장할 때, 동시에 데이터 소스에도 데이터를 저장하는 패턴.
  - 장점: 캐시와 데이터 소스 간의 동기화가 유지되며, 데이터 일관성이 높음.
  - 단점: 쓰기 작업이 느려질 수 있으며, 캐시 제공자가 데이터 소스와의 통합을 지원해야 함.
- Write Back Pattern
  - 설명: 애플리케이션이 데이터를 캐시에 저장할 때, 데이터 소스에는 즉시 저장하지 않고 일정 시간 후에 일괄적으로 저장하는 패턴.
  - 장점: 쓰기 작업이 빠르며, 데이터 소스에 대한 부하를 줄일 수 있음.
  - 단점: 데이터 일관성이 낮아질 수 있으며, 캐시 장애 시 데이터 손실 위험이 있음.
- Refresh Ahead Pattern
  - 설명: 캐시된 데이터가 만료되기 전에 백그라운드에서 미리 데이터를 갱신하는 패턴.
  - 장점: 캐시 미스를 줄이고, 애플리케이션의 응답 시간을 향상시킴.
  - 단점: 추가적인 리소스가 필요하며, 갱신 주기를 적절히 설정해야 함.
- Write Around Pattern
  - 설명: 애플리케이션이 데이터를 캐시에 저장하지 않고, 직접 데이터 소스에 저장하는 패턴.
  - 장점: 캐시 오염을 방지할 수 있으며, 자주 변경되는 데이터에 적합함.
  - 단점: 캐시 미스가 자주 발생할 수 있으며, 데이터 소스에 대한 부하가 증가할 수 있음.
- Lazy Loading Pattern
  - 설명: 데이터가 실제로 필요할 때까지 캐시에 로드하지 않는 패턴.
  - 장점: 초기 로딩 시간을 줄이고, 불필요한 데이터 로드를 방지함.
  - 단점: 첫 번째 접근 시 지연이 발생할 수 있으며, 캐시 미스가 자주 발생할 수 있음.
- Time-Based Expiration
  - 설명: 캐시된 데이터에 만료 시간을 설정하여 일정 시간이 지나면 자동으로 무효화하는 전략.
  - 장점: 오래된 데이터를 자동으로 제거하여 캐시의 신선도를 유지함.
  - 단점: 만료 시간이 짧으면 캐시 미스가 자주 발생할 수 있음.
- Size-Based Eviction
  - 설명: 캐시의 크기가 일정 한도를 초과할 때, 오래된 데이터나 덜 사용된 데이터를 제거하는 전략.
  - 장점: 캐시 크기를 제어하여 메모리 사용을 최적화함.
  - 단점: 중요한 데이터가 제거될 수 있으며, 캐시 미스가 발생할 수 있음.
- Distributed Caching
  - 설명: 여러 서버나 노드에 걸쳐 캐시를 분산하여 저장하는 전략.
  - 장점: 확장성이 뛰어나고, 대규모 애플리케이션에 적합함.
  - 단점: 네트워크 지연 및 복잡한 동기화 문제가 발생할 수 있음.
- Hybrid Caching
  - 설명: 메모리 캐시와 디스크 캐시를 결합하여 사용하는 전략.
  - 장점: 빠른 접근 속도와 대용량 저장 공간을 동시에 제공
  - 단점: 구현이 복잡할 수 있으며, 관리가 어려울 수 있음.
- Multi-Level Caching
  - 설명: 여러 계층의 캐시(예: L1, L2 캐시)를 사용하여 데이터 접근 속도를 최적화하는 전략.
  - 장점: 다양한 접근 속도 요구사항을 충족시킬 수 있음.
  - 단점: 구현 및 관리가 복잡할 수 있음.
- Cache Warming
  - 설명: 사전에 예상되는 데이터 요청을 미리 캐시에 로드하여 초기 응답 시간을 단축하는 전략.
  - 장점: 초기 요청 시 빠른 응답을 제공함.
  - 단점: 불필요한 데이터 로드로 인해 리소스 낭비가 발생할 수 있음.
- Read-Through with Write-Behind
  - 설명: 캐시가 데이터 소스와 통합되어 있어, 애플리케이션이 캐시에서 데이터를 조회할 때 캐시에 데이터가 없으면 자동으로 데이터 소스에서 데이터를 가져와 캐시에 저장하며, 쓰기 작업은 일정 시간 후에 일괄적으로 데이터 소스에 저장하는 패턴.
  - 장점: 읽기 작업의 성능을 향상시키고, 쓰기 작업의 부하를 줄일 수 있음.
  - 단점: 데이터 일관성이 낮아질 수 있으며, 캐시 장애 시 데이터 손실 위험이 있음.

## 캐시 무효화 전략
- Time-to-Live (TTL)
  - 설명: 캐시된 데이터에 일정 시간이 지나면 자동으로 무효화되는 만료 시간을 설정하는 전략.
  - 장점: 오래된 데이터를 자동으로 제거하여 캐시의 신선도를 유지함.
  - 단점: 만료 시간이 짧으면 캐시 미스가 자주 발생할 수 있음.
- Least Recently Used (LRU)
  - 설명: 가장 오랫동안 사용되지 않은 데이터를 우선적으로 제거하는 전략.
  - 장점: 자주 사용되는 데이터를 캐시에 유지하여 효율성을 높임.
  - 단점: 구현이 복잡할 수 있으며, 특정 사용 패턴에서 비효율적일 수 있음.
- First In First Out (FIFO)
  - 설명: 가장 먼저 캐시에 저장된 데이터를 우선적으로 제거하는 전략.
  - 장점: 구현이 간단하며, 일정한 캐시 교체 정책을 제공함.
  - 단점: 자주 사용되는 데이터가 제거될 수 있어 효율성이 낮아질 수 있음.
- Manual Invalidation
  - 설명: 애플리케이션에서 특정 이벤트나 조건에 따라 캐시를 수동으로 무효화하는 전략.
  - 장점: 특정 상황에 맞게 캐시를 제어할 수 있음.
  - 단점: 애플리케이션 코드가 복잡해질 수 있으며, 관리가 어려울 수 있음.
- Event-Driven Invalidation
  - 설명: 데이터 변경 이벤트(예: 데이터베이스 업데이트 등)에 따라 자동으로 캐시를 무효화하는 전략.
  - 장점: 데이터 일관성을 유지하면서 캐시를 관리할 수 있음.
  - 단점: 이벤트 처리 시스템이 필요하며, 구현이 복잡할 수 있음.
- Versioning
  - 설명: 캐시된 데이터에 버전 정보를 추가하여, 데이터가 변경될 때 버전이 다른 데이터를 무효화하는 전략.
  - 장점: 데이터 일관성을 유지하면서 캐시를 관리할 수 있음.
  - 단점: 버전 관리가 복잡해질 수 있으며, 추가적인 저장 공간이 필요함.
- Probabilistic Invalidation
  - 설명: 확률적으로 캐시된 데이터를 무효화하는 전략으로, 일정 확률로 데이터를 갱신하거나 제거함.
  - 장점: 캐시 관리의 복잡성을 줄일 수 있음.
  - 단점: 데이터 일관성이 낮아질 수 있으며, 예측 불가능한 동작이 발생할 수 있음.
- Hybrid Invalidation
  - 설명: 여러 무효화 전략을 결합하여 사용하는 전략으로, 상황에 따라 적절한 무효화 방법을 선택함.
  - 장점: 다양한 상황에 대응할 수 있어 유연성이 높음.
  - 단점: 구현 및 관리가 복잡할 수 있음.
